// 2013-08-16 Yu Yahagi
// Time evolution of elastic modes in an elliptical disk on the substrate.
// Saves the displacement vectors in a text file at a certain time interval.
// The format is as follows.
// Line 1    : [number of elements]
// Line 2-EOF: u1 u2 u3

load "msh3"
load "medit"

//////////////////////////////////////////////////////////////////////////////
// Material parameters
//////////////////////////////////////////////////////////////////////////////
mesh3	Th = readmesh3("../gmsh_meshes/Ni_ellipse150x75x30nm_Si_sub_p212nm_L10um_periodic_top.mesh");
//plot(Th, wait=1);
string	filename = "test_beam.txt";

real E1 = 1.85e-22, nu1 = 0.28; // E [kg/(nm ps^2)] for the ellipse
real rho1 = 2.3290e-24;       // rho [kg/nm^3]
real E2 = 1.85e-22, nu2 = 0.28; // E [kg/(nm ps^2)] for the substrate
real rho2 = 2.3290e-24;       // rho [kg/nm^3]

//////////////////////////////////////////////////////////////////////////////
// Finite Element spaces, functions, and macros
//////////////////////////////////////////////////////////////////////////////
fespace Vh(Th, [P1,P1,P1], periodic=[[7,y,z],[9,y,z],[6,x,z],[8,x,z]]);
fespace VhScalar(Th, P1, periodic=[[7,y,z],[9,y,z],[6,x,z],[8,x,z]]);
Vh [u1,u2,u3], [v1,v2,v3], [uu1,uu2,uu3], [uuu1,uuu2,uuu3];
Vh [ur1,ur2,ur3];			// For visualization
Vh [f1,f2,f3] = [0.0, 0.0, 0.0];	// Boundary condition at the bottom
VhScalar uAbs, ur, uphi;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM

func real funcE() {
  if (z > 0) return E1; else return E2/2;
}

func real funcNu() {
  if (z > 0) return nu1; else return nu2/2;
}

func real funcRho() {
  if (z > 0) return rho1; else return rho2/2;
}

VhScalar E = funcE();
VhScalar nu = funcNu();
VhScalar mu = funcE()/(2*(1+funcNu()));
VhScalar lambda = funcE()*funcNu()/((1+funcNu())*(1-2*funcNu()));
VhScalar rho = funcRho();

int i;
for (i=0; i<120; i++) {
  cout << "z = " << (i-60)/2 << ", E = " << E(0, 0, (i-60)/2) << endl;
}

//////////////////////////////////////////////////////////////////////////////
// Initial displacement and time evolution parameters
//////////////////////////////////////////////////////////////////////////////
func u10 = 1e-5*x*exp(-(z-30)^2/5^2)*exp(-((2*x)^2+y^2)/40^2);
func u20 = 1e-5*y*exp(-(z-30)^2/5^2)*exp(-((2*x)^2+y^2)/40^2);
func u30 = 1e-5  *exp(-(z-30)^2/5^2)*exp(-((2*x)^2+y^2)/40^2);

real dt = 0.4, T;
real[int] viso(20);
for(int i=0; i<20; i++) {
	viso[i] = -1.8 + i*0.2;
}
T = 2500.0;

cout << "E = " << E << ", nu = " << nu << ", rho = " << rho << ", mu = " << mu << ", lambda = " << lambda << endl;
cout << "dt = " << dt << ", T = " << T << endl;
//plot(Th, wait=1);

problem pulse([u1,u2,u3],[v1,v2,v3]) =
	int3d(Th)(
		lambda*div(u1,u2,u3)*div(v1,v2,v3) + 2.*mu*epsilon(u1,u2,u3)'*epsilon(v1,v2,v3)
		+ rho/dt^2*(u1*v1+u2*v2+u3*v3)
	)
	+ int3d(Th)(
		rho/dt^2 * ( (-2*uu1+uuu1)*v1 + (-2*uu2+uuu2)*v2 + (-2*uu3+uuu3)*v3 )
	)
	+ on(5, u1=f1, u2=f2, u3=f3)
	+ on(7, 9, 11, 13, u1=f1)
	+ on(6, 8, 10, 12, u2=f2)
;

real t = 0;
[u1,u2,u3] = [u10,u20,u30];
[uu1,uu2,uu3] = [u10,u20,u30];
[uuu1,uuu2,uuu3] = [u10,u20,u30];
plot(u1, wait=1, nbiso=20, value=1, dim=2, cmm="u10");
plot(u2, wait=1, nbiso=20, value=1, dim=2, cmm="u20");
plot(u3, wait=1, nbiso=20, value=1, dim=2, cmm="u30");
real dmax=1.0e-30;
real coef = 3000;//1.0/dmax;
int[int]	ref2=[1,0,2,0];
mesh3 ThM;
{
	ofstream ofileTime(filename+"_time.txt");
	ofstream ofileIndex(filename+"_displacement.txt");
	ofileTime << "#t "
		<< "u1( 0, 0,  0) u2( 0, 0,  0) u3( 0, 0,  0) "
		<< "u1( 0, 0, 15) u2( 0, 0, 15) u3( 0, 0, 15) "
		<< "u1( 0, 0, 30) u2( 0, 0, 30) u3( 0, 0, 30) "
		<< "u1( 0, 0,-15) u2( 0, 0,-15) u3( 0, 0,-15) "
		<< "u1(30, 0,  0) u2(30, 0,  0) u3(30, 0,  0) "
		<< "u1(30, 0, 15) u2(30, 0, 15) u3(30, 0, 15) "
		<< "u1(30, 0, 30) u2(30, 0, 30) u3(30, 0, 30) "
		<< "u1(30, 0,-15) u2(30, 0,-15) u3(30, 0,-15) "
		<< "u1( 0,60,  0) u2( 0,60,  0) u3( 0,60,  0) "
		<< "u1( 0,60, 15) u2( 0,60, 15) u3( 0,60, 15) "
		<< "u1( 0,60, 30) u2( 0,60, 30) u3( 0,60, 30) "
		<< "u1( 0,60,-15) u2( 0,60,-15) u3( 0,60,-15) "
		<< "u1( 0, 0,-9950) u2(0, 0,-9950) u3( 0, 0,-9950)" << endl;
	ofileIndex << "#file_index t(ps)" << endl;

	for(int m=0; m<=T/dt; m++) {
		t = t + dt;
		pulse;

		uAbs = sqrt(u1^2+u2^2+u3^2);
		//[ur1,ur2,ur3] = [u1-u1(0,0,0), u2-u2(0,0,0), u3-u3(0,0,0)];
		//plot(u1, wait=0, fill=0, nbiso=20, value=1, dim=2, cmm="X, t = "+t+" ps (dt ="+dt+")");
		//plot(u2, wait=0, fill=0, nbiso=20, value=1, dim=2, cmm="Y, t = "+t+" ps (dt ="+dt+")");
		//plot(u3, wait=0, fill=0, nbiso=20, value=1, dim=2, cmm="Z, t = "+t+" ps (dt ="+dt+")");
		//plot([u1,u2,u3], wait=false, fill=true, value=1, dim=2, coef=1e30);
		//plot(u1,u2, wait=0,fill=true,dim=2);

		// Plot with deformed mesh
		dmax = uAbs[].max;
		coef = 20.0/dmax;
		ThM=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef]);
		plot(ThM, u3, wait=0, fill=0, nbiso=20, value=1, cmm="Z, t = "+t+" ps (dt ="+dt+"), coef amplification = "+coef);
		//plot(ThM, wait=0, fill=0, nbiso=20, value=1, cmm="Z, t = "+t+" ps (dt ="+dt+"), coef amplification = "+coef);

		ofileTime << t 
			<< " " << u1( 0, 0,  0) << " " << u2( 0, 0,  0) << " " << u3( 0, 0,  0)
			<< " " << u1( 0, 0, 15) << " " << u2( 0, 0, 15) << " " << u3( 0, 0, 15)
			<< " " << u1( 0, 0, 30) << " " << u2( 0, 0, 30) << " " << u3( 0, 0, 30)
			<< " " << u1( 0, 0,-15) << " " << u2( 0, 0,-15) << " " << u3( 0, 0,-15)
			<< " " << u1(30, 0,  0) << " " << u2(30, 0,  0) << " " << u3(30, 0,  0)
			<< " " << u1(30, 0, 15) << " " << u2(30, 0, 15) << " " << u3(30, 0, 15)
			<< " " << u1(30, 0, 30) << " " << u2(30, 0, 30) << " " << u3(30, 0, 30)
			<< " " << u1(30, 0,-15) << " " << u2(30, 0,-15) << " " << u3(30, 0,-15)
			<< " " << u1( 0,60,  0) << " " << u2( 0,60,  0) << " " << u3( 0,60,  0)
			<< " " << u1( 0,60, 15) << " " << u2( 0,60, 15) << " " << u3( 0,60, 15)
			<< " " << u1( 0,60, 30) << " " << u2( 0,60, 30) << " " << u3( 0,60, 30)
			<< " " << u1( 0,60,-15) << " " << u2( 0,60,-15) << " " << u3( 0,60,-15)
			<< " " << u1( 0, 0,-9950) << " " << u2( 0, 0,-9950) << " " << u3( 0, 0,-9950) << endl;

		if(rint(10*t) % 20 == 0) {
			ofileIndex << m << " " << t << endl;
			savemesh(Th, filename+"."+(100000+10*t)+".meshb");
			{
				ofstream ofileVector(filename+"."+(100000+10*t)+".txt");
				ofileVector << u1[].n << endl;
				for (int j=0; j<u1[].n; j++) {
					ofileVector << u1[][j] << " " << u2[][j] << " " << u3[][j] << endl;
				}
			}
		}

		//[w1,w2] = [u1(x,y,25),u2(x,y,25)];
		//plot([w1,w2],coef=1e22,wait=false,dim=2);

		[uuu1,uuu2,uuu3] = [uu1,uu2,uu3];
		[uu1,uu2,uu3] = [u1,u2,u3];
		cout << "t = " << t << " L^2-Error = " << sqrt(int3d(Th)((u3-t*z^4)^2)) << endl;
	}
}
